<template xmlns="http://www.example.com/xsd2cocoa"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.example.com/xsd2cocoa template.xsd">
  <format_style type="builtin"/>
  <additional_file path="libxml-bridging-header.header"
  target_path="libxml-bridging-header.h" />
  <!-- known simpletypes-->
  <simpletype name="string" objType="String" arrayType="[String]">
    <read>
      <prefix></prefix>
      <attribute>
        <![CDATA[
        {% if attribute.hasEnumeration %}self.{{ attribute.variableName }} = {{ attribute.schemaType.enumerationName }}.fromString(String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))){% else %}self.{{ attribute.variableName }} = String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue)){% /if %}]]>
        </attribute>
      <element>
        <![CDATA[
            {% if element.isSingleValue %}self.{{ element.variableName }} = String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))
            {% else %}{{ element.variableName }}Array.append(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))){% /if %}]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
        self.value = value]]>
        </value>
    </read>
  </simpletype>
  <simpletype name="anyURI" objType="NSURL" arrayType="[NSURL]">
    <read>
      <prefix></prefix>
      <attribute>
        <![CDATA[
        self.{{ attribute.variableName }} = NSURL(string: String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))!)]]>
        </attribute>
      <element>
          <![CDATA[
              {% if element.isSingleValue %}self.{{ element.variableName }} = NSURL(string: String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
              {% else %}{{ element.variableName }}Array.append(NSURL(string: String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!) //bad unwrapping{% /if %}]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
        self.value = NSURL(string: value)]]>
        </value>
    </read>
  </simpletype>
  <simpletype name="boolean" objType="Bool" arrayType="[Bool]">
    <read>
      <prefix></prefix>
      <attribute>
        <![CDATA[
        self.{{ attribute.variableName }} = (String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue)) == "true")]]>
        </attribute>
      <element>
          <![CDATA[
              {% if element.isSingleValue %}self.{{ element.variableName }} = String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue)) == "true"
              {% else %}{{ element.variableName }}Array.append(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue)) == "true"){% /if %}]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
        self.value = (value == "true")]]>
        </value>
    </read>
  </simpletype>
  <simpletype name="integer" objType="Int" arrayType="[Int]">
    <read>
      <prefix>
        <![CDATA[
        let numFormatter = NSNumberFormatter()
        numFormatter.numberStyle = NSNumberFormatterStyle.DecimalStyle
        numFormatter.locale = self.locale
        ]]>
        </prefix>
      <attribute>
        <![CDATA[
        self.{{ attribute.variableName }} = numFormatter.numberFromString(String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))!)!.integerValue]]>
        </attribute>
      <element>
          <![CDATA[
              {% if element.isSingleValue %}self.{{ element.variableName }} = numFormatter.numberFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!.integerValue
              {% else %}{{ element.variableName }}Array.append(numFormatter.numberFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!.integerValue)  //bad force unwrapping{% /if %}]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
        if value != nil {
            let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
            self.value = numFormatter.numberFromString(trimmed).integerValue
        }]]>
        </value>
    </read>
  </simpletype>
  <simpletype name="decimal" objType="Double" arrayType="[Double]">
    <read>
      <prefix>
        <![CDATA[
        let decFormatter = NSNumberFormatter()
        decFormatter.numberStyle = NSNumberFormatterStyle.DecimalStyle
        decFormatter.locale = self.locale]]>
        </prefix>
      <attribute>
        <![CDATA[
        self.{{ attribute.variableName }} = decFormatter.numberFromString(String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))!)!.doubleValue]]>
        </attribute>
      <element>
          <![CDATA[
              {% if element.isSingleValue %}self.{{ element.variableName }} = decFormatter.numberFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!.doubleValue
              {% else %}{{ element.variableName }}Array.append(decFormatter.numberFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!.doubleValue) //bad force unwrapping{% /if %}]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
        if value != nil {
            let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
            self.value = decFormatter.numberFromString(trimmed)!.doubleValue
        }]]>
        </value>
    </read>
  </simpletype>
  <simpletype name="dateTime" objType="Date"
  arrayType="[Date]">
    <read>
      <prefix>
        <![CDATA[
            let sRFC3339DateFormatterSubSeconds = NSDateFormatter()
            sRFC3339DateFormatterSubSeconds.locale = self.locale
            sRFC3339DateFormatterSubSeconds.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.SSSSSSXXXXX"
            sRFC3339DateFormatterSubSeconds.timeZone = NSTimeZone(forSecondsFromGMT: 0)
            
            let sRFC3339DateFormatter = NSDateFormatter()
            sRFC3339DateFormatter.locale = self.locale
            sRFC3339DateFormatter.dateFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ssXXXXX"
            sRFC3339DateFormatterSubSeconds.timeZone = NSTimeZone(forSecondsFromGMT: 0)]]></prefix>
      <attribute>
        <![CDATA[
        self.{{ attribute.variableName }} = sRFC3339DateFormatter.dateFromString( String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))! )
            if(self.{{ attribute.variableName }} == nil) {
            self.{{ attribute.variableName }} = sRFC3339DateFormatterSubSeconds.dateFromString( String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))!)
            }]]>
        </attribute>
      <element>
          <![CDATA[
              {% if element.isSingleValue %}self.{{ element.variableName }} = sRFC3339DateFormatter.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
              if(self.{{ element.variableName }} == nil) {
                  self.{{ element.variableName }} = sRFC3339DateFormatterSubSeconds.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
              }
              {% else %}var {{ element.variableName }}Temp = sRFC3339DateFormatter.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
              if({{element.variableName }}Temp == nil) {
                  {{ element.variableName }}Temp = sRFC3339DateFormatterSubSeconds.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
              }
              {{ element.variableName }}Array.append(!) //bad force unwrapping{% /if %}]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
        if value != nil {
            let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
            self.value = sRFC3339DateFormatter.dateFromString(trimmed)
            if(!self.value) {
                self.value = sRFC3339DateFormatterSubSeconds.dateFromString(trimmed)
            }
        }]]>
        </value>
    </read>
  </simpletype>
  <simpletype name="date" objType="Date"
      arrayType="[Date]">
      <read>
          <prefix>
              <![CDATA[let dateOnlyFormatter = NSDateFormatter()
                  dateOnlyFormatter.dateFormat = "yyyy-MM-dd"
                  dateOnlyFormatter.timeZone = NSTimeZone(name:"UTC")
                  dateOnlyFormatter.locale = self.locale
              ]]>
          </prefix>
          <attribute>
              <![CDATA[
                  self.{{ attribute.variableName }} = dateOnlyFormatter.dateFromString( String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))!)]]>
          </attribute>
          <element>
              <![CDATA[
                  {% if element.isSingleValue %}self.{{ element.variableName }} = dateOnlyFormatter.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
                  {% else %}{{ element.variableName }}Array.append(dateOnlyFormatter.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!) //bad force unwrapping{% /if %}]]>
          </element>
          <value>
              <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
                  if value != nil {
                  let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                  self.value = dateOnlyFormatter.dateFromString(trimmed)
                  }]]>
          </value>
      </read>
  </simpletype>
  <simpletype name="time" objType="Date"
      arrayType="[Date]">
      <read>
          <prefix>
              <![CDATA[let timeOnlyFormatter = NSDateFormatter()
                  timeOnlyFormatter.dateFormat = "HH:mm:ss"
                  timeOnlyFormatter.timeZone = NSTimeZone(name:"UTC")
                  timeOnlyFormatter.locale = self.locale
              ]]>
          </prefix>
          <attribute>
              <![CDATA[
                  self.{{ attribute.variableName }} = timeOnlyFormatter.dateFromString( String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue))!)]]>
          </attribute>
          <element>
              <![CDATA[
                  {% if element.isSingleValue %}self.{{ element.variableName }} = timeOnlyFormatter.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)
                  {% else %}{{ element.variableName }}Array.append(timeOnlyFormatter.dateFromString(String.fromCString(UnsafePointer<CChar>({{element.name}}ElementValue))!)!) //bad force unwrapping{% /if %}]]>
          </element>
          <value>
              <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
                  if value != nil {
                  let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                  self.value = timeOnlyFormatter.dateFromString(trimmed)
                  }]]>
          </value>
      </read>
  </simpletype>
  <!--complex type-->
  <complextype objType="@objc-Subclass"
  arrayType="[{{ type.targetClassName }}]">
    <read>
      <element>
        <![CDATA[
        {% if element.isSingleValue %}self.{{ element.variableName }} = {{ element.codeType }}(reader: reader){% else %}{{ element.variableName }}Array.append({{ element.schemaType.targetClassName }}(reader: reader)){% /if %}]]>
        </element>
    </read>
    <implementation>
      <header extension=""></header>
      <class extension="swift">
        <![CDATA[//
        //  {{ type.targetClassName }}.swift
        //  targetNamespace = {{ type.schema.targetNamespace }}
        //
        //  Created by xsd2cocoa/XSDConverter.
        //  Copyright (c) 2018 EHI. All rights reserved.
        //
        
        import Foundation

        class {{ type.targetClassName }} {% if type.hasComplexBaseClass %}: {{ type.baseClass.targetClassName }} {%else %}: NSObject, Codable {% /if %}{

            {% for attribute in type.attributes %}
            var {{ attribute.variableName }}: {% if attribute.hasEnumeration %}{{ attribute.schemaType.enumerationName }}{% else %}{{ attribute.codeType }}{% /if %}?
            {% /for %}
            {% for element in type.elements %}var {{ element.variableName }}: {% if element.hasEnumeration %}{{ element.schemaType.enumerationName }}{% else %}{{ element.codeType }}{% /if %}{% if element.isNotOptionalOrNotMultiple %}!{% else %}?{% /if %}
            {% /for %}
            {% if type.hasSimpleBaseClass %}/**
            the type's underlying value
            */
            var value: {% if type.baseClass.hasEnumeration %}{{ type.baseClass.enumerationName }}{% else %}{{ type.baseClass.targetClassName }}{% /if %}?{% /if %}
            
            {% if type.hasElements %}private enum CodingKeys: String, CodingKey {
                {% for element in type.elements %}case {{element.variableName}} = "{{element.codingKeyName}}"
                {% /for %}
            }
            {% /if %}

            {% if type.hasElements %}
            required init(from decoder: Decoder) throws {
                {% if type.hasComplexBaseClass %}try super.init(from: decoder){% else %}super.init(){% /if %}
     
                let values = try decoder.container(keyedBy: CodingKeys.self)
                
                {% for element in type.elements %}{% if element.hasEnumeration %}{{ element.variableName }} = try? values.decode({{ element.schemaType.enumerationName }}.self, forKey: .{{element.variableName}}){% else %}{{ element.variableName }} = {% if element.isNotOptionalOrNotMultiple %}({% else %}{% /if %}try? values.decode({{ element.codeType }}.self, forKey: .{{element.variableName}}){% /if %}{% if element.isNotOptionalOrNotMultiple %}) ?? {{ element.defaultOptional }}{% else %}{% /if %}
                {% /for %}
                
            }
            {% /if %}
            
        }]]>
        </class>
    </implementation>
    <reader>
      <header extension=""></header>
      <class extension="swift">
        <![CDATA[//
            //  {{ type.targetClassFileName }}.swift
            //  targetNamespace = {{ type.schema.targetNamespace }}
            //
            //  Created by xsd2cocoa/XSDConverter.
            //  Copyright (c) 2018 EHI. All rights reserved.
            //
            
            import Foundation
            
            let kGlobalElementNamesArray = ["##elements##"{% for element in type.globalElements %},"{{ element.name }}"{% /for %}]

            extension {{ type.targetClassFileName }} {
                class func {{ type.name }}FromURL(url:NSURL) -> {{ type.targetClassName }}? {
                    let s = (url.absoluteString as NSString).UTF8String
                    let reader = xmlReaderForFile( s, nil, 0/*options*/)
                    var ret: Int32
                    var obj: {{ type.targetClassName }}? = nil
                    
                    if(reader != nil) {
                        //find the correct root
                        repeat {
                            ret = xmlTextReaderRead(reader)
                            if(ret == 1/*XML_READER_TYPE_ELEMENT*/) {
                                let elementNameXmlChar = xmlTextReaderConstLocalName(reader)
                                let elementName = String.fromCString(UnsafePointer<CChar>(elementNameXmlChar))
                                let array = [kGlobalElementNamesArray]
                                let predicate = NSPredicate(format: "SELF IN %@", argumentArray: array)
                                if(predicate.evaluateWithObject(elementName)) {
                                    obj = {{ type.targetClassName }}(reader: reader)
                                    break
                                }
                            }
                        } while(ret != 0)
                        xmlFreeTextReader(reader)
                    }
                    
                    return obj
                }
                
                class func {{ type.name }}FromFile(path:String) -> {{ type.targetClassName }}? {
                    let url = NSURL(fileURLWithPath:path)
                    return self.{{ type.name }}FromURL(url)
                }
                
                class func {{ type.name }}FromData(data:NSData) -> {{ type.targetClassName }}? {
                    let bytes = UnsafePointer<Int8>(data.bytes)
                    let length = Int32(data.length)
                    let reader = xmlReaderForMemory(bytes, length, nil, nil, 0/*options*/)
                    
                    if(reader != nil) {
                        let ret = xmlTextReaderRead(reader)
                        if(ret > 0) {
                            return {{ type.targetClassName }}(reader: reader)
                        }
                        xmlFreeTextReader(reader)
                    }
                    
                    return nil
                }
            }]]>
        </class>
    </reader>
  </complextype>
  <enumeration objType="NS_ENUM" arrayType="">
    <read>
      <prefix></prefix>
      <attribute>
        <![CDATA[
            self.{{ attribute.variableName }} = {{ attribute.schemaType.enumerationName }}.fromString(String.fromCString(UnsafePointer<CChar>({{ attribute.name }}AttrValue)))
            ]]>
        </attribute>
      <element>
        <![CDATA[
            self.{{ element.variableName }} = {{ element.schemaType.enumerationName }}.fromString(String.fromCString(UnsafePointer<CChar>({{ element.name }}ElementValue)))
            ]]>
        </element>
      <value>
        <![CDATA[let value = String.fromCString(UnsafePointer<CChar>(contentValue))
            if value != nil {
                let trimmed = value!.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                self.value = {{ type.enumerationName }}.fromString(trimmed)
            }]]>
        </value>
    </read>
    <implementation>
      <header extension=""></header>
      <class extension="swift">
        <![CDATA[//
            //  {{ type.enumerationName }}.swift
            //  targetNamespace = {{ type.schema.targetNamespace }}
            //
            //  Created by xsd2cocoa/XSDConverter.
            //  Copyright (c) 2018 EHI. All rights reserved.
            //
            
            import Foundation
            
            enum {{ type.enumerationName }} : String, Codable {
                {% for enum in type.enumerations %}case {{ enum.formattedValue }} = "{{ enum.value }}"
                {% /for %}
            }]]>
        </class>
    </implementation>
  </enumeration>
</template>
